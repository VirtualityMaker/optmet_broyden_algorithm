{
    "contents" : "source(\"1d_search.r\");\nsource(\"data.r\");\n\nf_by_direction <- function(f, start_point, direction)\n{\n    return(function(lambda){ f(start_point + lambda * direction); });\n}\n\nget_next_hesse_approximation <- function(prev_A, delta_x, delta_g)\n{\n    delta_x = matrix(delta_x, nrow=2, ncol=1)\n    delta_g = matrix(delta_g, nrow=2, ncol=1)\n    \n    #~ broidena-shafe\n    \n    #mult1 = diag(2) - (delta_x %*% t(delta_g)) / (t(delta_x) %*% delta_g)[1,1]\n    #mult2 = (delta_x %*% t(delta_x)) / (t(delta_x) %*% delta_g)[1,1]\n\n    #A = mult1 %*% prev_A %*% mult1 + mult2\n    \n    #~ broidena\n    \n    mult1 = delta_x - prev_A %*% delta_g\n  \n    A = prev_A + (mult1 %*% t(mult1)) / (t(mult1) %*% delta_g)[1,1]\n    \n    #~ devisona-fletchera-pauella\n    \n    #mult1 = (delta_x %*% t(delta_x)) / (t(delta_x) %*% delta_g)[1,1]\n    #mult2 = (prev_A %*% delta_g %*% t(delta_g) %*% prev_A) / (t(delta_g) %*% prev_A %*% delta_g)[1,1]\n    \n    #A = prev_A + mult1 - mult2\n    \n    cat(\"\\nApproximated matrix:\\n\")\n    print(A)\n    cat(\"\\n\")\n    \n    return(A)\n}\n\nget_svenn_accuracy <- function(i)\n{\n  #if (i < 3) {\n  #  0.001\n  #} else if (i < 17) {\n    #0.001 * (0.9 ^ i)  \n  #  0.00001\n  #} else {\n  #  10^(-4)\n  #}  \n  #10^(-2)\n  10^(-11)\n}\n\nget_1d_accuracy <- function(i)\n{\n  #if (i < 3) {\n  #  10^(-8)\n  #} else if (i < 10) {\n  #  10^(-2) \n  #} else {\n  #  10^(-8)\n  #}  \n  10^(-12)\n}\n\nx_prev = c(-1, 2)\nA0 = matrix(c(1,0,0,1),nrow=2,ncol=2)\n#x_prev = c(-1, 1)\nA_prev = A0\n\ncat(\"Start point: \\n\")\nprint(x_prev)\ncat(\"Start Hesse approximation: \\n\")\nprint(A_prev)\ncat(\"\\n\")\n\nx_points = c()\ny_points = c()\nz_points = c()\n\npoints = list()\npoints[[1]] = c(x_prev, f(x_prev))\nx_points = c(x_points, x_prev[1])\ny_points = c(y_points, x_prev[2])\nz_points = c(z_points, f(x_prev))\n\nrestarts = list()\n\nmaximum_iterations_number = 100\nepsilon_for_finish_criteria = 10^(-6)\n\niteration_number = 0\nadjacent_restarts_number = 0\n\nabs_of_deltag = Inf\nnorm_of_deltax = Inf\n\nfor (i in 1:maximum_iterations_number) {\n  if (adjacent_restarts_number == 2) break\n  \n  iteration_number = iteration_number + 1\n  \n  cat(\"--------- Iteration #\", i, \" --------\\n\\n\")\n  eigenvals = eigen(A_prev, TRUE, TRUE)\n  \n  for (j in 1:length(eigenvals$values)) {\n    if (eigenvals$values[j] < 0) {\n      cat(\"Not positive definite matrix!\\n\")\n      \n      if (A_prev[1,1] == 0) A_prev[1,1] = 0.0001;\n      if (A_prev[2,2] == 0) A_prev[2,2] = 0.0001;\n      \n      C_ = matrix(c(1/(abs(A_prev[1,1])^0.5), 0, 0, 1/(abs(A_prev[2,2])^0.5)), nrow=2, ncol=2)\n      P = C_ %*% A_prev %*% C_\n      \n      ev = eigen(P, TRUE)\n      \n      for (t in 1:length(ev$values)) {\n        if (ev$values[t] < 10^(-4)) {\n          ev$values[t] = 10^(-4) \n        }\n      }\n      \n      A_prev = abs(1/(ev$values[1])) * matrix(c(ev$vectors[1,1],ev$vectors[1,2],0,0), nrow=2, ncol=2) %*% \n        matrix(c(ev$vectors[1,1],0,ev$vectors[1,2],0), nrow=2, ncol=2) +\n        abs(1/(ev$values[2])) * matrix(c(ev$vectors[2,1],ev$vectors[2,2],0,0), nrow=2, ncol=2) %*% \n        matrix(c(ev$vectors[2,1],0,ev$vectors[2,2],0), nrow=2, ncol=2)\n      \n      print(A_prev)\n      cat(\"\\n\")\n      break\n    }\n  }\n\n  s = - A_prev %*% grad_f(x_prev);\n  \n  if (norm(s) < 0.00000000000001) {\n    cat(\"UNABLE TO MOVE!\\n\\n\")\n    break\n  }\n  \n  s = s / norm(s, \"f\") \n  \n  cat(\"Direction:        \\n\")\n  print(s)\n  cat(\"\\n\")\n  \n  #lambda=0.001\n  \n  #lambda = method_dsk(f_by_direction(f, x_prev, s), 0, get_svenn_accuracy(iteration_number), get_1d_accuracy(iteration_number))[1];\n\n  #svenn_bounds = svenn_algorithm(f_by_direction(f, x_prev, s), 0, get_svenn_accuracy(i))\n  #lambda = method_golden_ratio(f_by_direction(f, x_prev, s), svenn_bounds[[1]], svenn_bounds[[2]], get_1d_accuracy(i))\n  #lambda = (lambda[[1]][1] + lambda[[2]][1]) / 2\n  \n  #svenn_bounds = svenn_algorithm(f_by_direction(f, x_prev, s), 0, get_svenn_accuracy(i))\n  #lambda = method_dihotomy(f_by_direction(f, x_prev, s), svenn_bounds[[1]][1], svenn_bounds[[2]][1], get_1d_accuracy(i))\n  #lambda = lambda[1]\n  \n  lambda = method_dsk_pauell(f_by_direction(f, x_prev, s), 0, get_svenn_accuracy(iteration_number), get_1d_accuracy(iteration_number))[1]\n  \n  cat(\"Lamda:            \", lambda, \"\\n\")\n  \n  if (lambda < 10^(-8)) {\n    A_prev = A0\n    restarts[[length(restarts)+1]] = c(lambda[1], iteration_number)\n    adjacent_restarts_number = adjacent_restarts_number + 1\n    \n    cat(\"RESTART!\\n\\n\")\n    next\n  }\n  \n  adjacent_restarts_number = 0\n  \n  x_cur = x_prev + lambda * s\n  x_cur = c(x_cur[1,1], x_cur[2,1])\n  \n  cat(\"\\nx[\", i,\"]: \")\n  print(x_cur)\n  cat(\"\\n\")\n  \n  points[[length(points)+1]] = c(x_cur, f(x_cur))\n  x_points = c(x_points, x_cur[1])\n  y_points = c(y_points, x_cur[2])\n  z_points = c(z_points, f(x_cur))\n\n  norm_of_deltax = norm(matrix(x_prev - x_cur, nrow=1, ncol=2), \"f\")\n  abs_of_deltag  = abs(f(x_prev) - f(x_cur))\n  \n  cat(\"|f(x1) - f(x0)| = \")\n  print(abs_of_deltag)\n  cat(\"||x1 - x0||     = \")\n  print(norm_of_deltax)\n  \n  if (norm_of_deltax < epsilon_for_finish_criteria &&\n      abs_of_deltag < epsilon_for_finish_criteria) break\n  \n  #if (norm(matrix(grad_f(x_cur), nrow=1, ncol=2), \"f\") < epsilon_for_finish_criteria) break\n  #cat(\"||grad_f(x1)||     = \")\n  #print(norm(matrix(grad_f(x_cur), nrow=1, ncol=2), \"f\"))\n  \n  A_cur = get_next_hesse_approximation(A_prev, x_cur - x_prev, grad_f(x_cur) - grad_f(x_prev))\n\n  x_prev = x_cur\n  A_prev = A_cur\n}\n\ncat(\"Number of iterations:  \", iteration_number, \"\\n\")\ncat(\"Function calculations: \", length(unique(f_values)), \"\\n\")\ncat(\"Gradient calculations: \", length(unique(f_grad_values)), \"\\n\")\ncat(\"Points:\\n\")\nprint(points)\ncat(\"Restarts:\\n\")\nprint(restarts)\ncat(\"Last A:\\n\")\nprint(A_cur)\n\nx <- seq(-2, 2, length.out = 20)  \ny <- x\n\nrotf <- Vectorize(function(x,y){f(c(x,y))})\n\nz <- outer(x,y,rotf)\ncontour(x,y,z)\npoints(x_points, y_points, \"b\")\n",
    "created" : 1370702524906.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "250681356",
    "id" : "B13FCDC3",
    "lastKnownWriteTime" : 1370774790,
    "path" : "F:/PROJECTS/Education/3_kurs/2/Методы оптимизации/курсовая/broiden.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}