{
    "contents" : "source(\"1d_search.r\");\nsource(\"data.r\");\n\nf_by_direction <- function(f, start_point, direction)\n{\n    return(function(lambda){ f(start_point + lambda * direction); });\n}\n\nget_next_hesse_approximation <- function(prev_A, delta_x, delta_g)\n{\n    delta_x = matrix(delta_x, nrow=2, ncol=1)\n    delta_g = matrix(delta_g, nrow=2, ncol=1)\n    \n    #~ broidena-shafe\n    \n    #mult1 = diag(2) - (delta_x %*% t(delta_g)) / (t(delta_x) %*% delta_g)[1,1]\n    #mult2 = (delta_x %*% t(delta_x)) / (t(delta_x) %*% delta_g)[1,1]\n\n    #A = mult1 %*% prev_A %*% mult1 + mult2\n    \n    #~ broidena\n    \n    mult1 = delta_x - prev_A %*% delta_g\n  \n    A = prev_A + (mult1 %*% t(mult1)) / (t(mult1) %*% delta_g)[1,1]\n    \n    #~ devisona-fletchera-pauella\n    \n    #mult1 = (delta_x %*% t(delta_x)) / (t(delta_x) %*% delta_g)[1,1]\n    #mult2 = (prev_A %*% delta_g %*% t(delta_g) %*% prev_A) / (t(delta_g) %*% prev_A %*% delta_g)[1,1]\n    \n    #A = prev_A + mult1 - mult2\n    \n    cat(\"\\nApproximated matrix:\\n\")\n    print(A)\n    cat(\"\\n\")\n    \n    return(A)\n}\n\nget_svenn_accuracy <- function(i)\n{\n  0.6 ^ (i)\n}\n\nget_1d_accuracy <- function(i)\n{\n  10^(-3)\n}\n\nx_prev = c(-1.2, 0)\nA0 = matrix(c(1,0,0,1),nrow=2,ncol=2)\n#x_prev = c(-1, -1)\nA_prev = A0\n\ncat(\"Start point: \\n\")\nprint(x_prev)\ncat(\"Start Hesse approximation: \\n\")\nprint(A_prev)\ncat(\"\\n\")\n\nx_points = c()\ny_points = c()\nz_points = c()\n\npoints = list()\npoints[[1]] = c(x_prev, f(x_prev))\nx_points = c(x_points, x_prev[1])\ny_points = c(y_points, x_prev[2])\nz_points = c(z_points, f(x_prev))\n\nrestarts = list()\n\nmaximum_iterations_number = 100\nepsilon_for_finish_criteria = 10^(-6)\n\niteration_number = 0\nadjacent_restarts_number = 0\ngrinshtadts_recalculations = 0\n\nabs_of_deltag = Inf\nnorm_of_deltax = Inf\n\nfor (i in 1:maximum_iterations_number) {\n  if (adjacent_restarts_number == 2) break\n  \n  iteration_number = iteration_number + 1\n  \n  cat(\"--------- Iteration #\", i, \" --------\\n\\n\")\n  #eigenvals = eigen(A_prev, TRUE, TRUE)\n  \n  #for (j in 1:length(eigenvals$values)) {\n  #  if (eigenvals$values[j] < 0) {\n  #    cat(\"Not positive definite matrix!\\n\")\n  #    grinshtadts_recalculations = grinshtadts_recalculations + 1\n      \n  #    if (abs(A_prev[1,1]) < 0.0001) A_prev[1,1] = 0.0001;\n  #    if (abs(A_prev[2,2]) < 0.0001) A_prev[2,2] = 0.0001;\n      \n  #    C_ = matrix(c((1/abs(A_prev[1,1])^0.5), 0, 0, (abs(1/A_prev[2,2])^0.5)), nrow=2, ncol=2)\n  #    P = C_ %*% A_prev %*% C_\n      \n  #    ev = eigen(P, TRUE)\n      \n  #    for (t in 1:length(ev$values)) {\n  #      if (ev$values[t] < 10^(-4)) {\n  #        ev$values[t] = 10^(-4) \n  #      }\n  #    }\n      \n  #    A_prev = abs(ev$values[1]) * matrix(c(ev$vectors[1,1],ev$vectors[1,2],0,0), nrow=2, ncol=2) %*% \n  #      matrix(c(ev$vectors[1,1],0,ev$vectors[1,2],0), nrow=2, ncol=2) +\n  #      abs(ev$values[2]) * matrix(c(ev$vectors[2,1],ev$vectors[2,2],0,0), nrow=2, ncol=2) %*% \n  #      matrix(c(ev$vectors[2,1],0,ev$vectors[2,2],0), nrow=2, ncol=2)\n      \n  #    print(A_prev)\n  #    cat(\"\\n\")\n  #    break\n  #  }\n  #}\n\n  s = - A_prev %*% grad_f(x_prev);\n  \n  #cat(\"||grad_f(x1)||     = \")\n  #print(norm(matrix(s, nrow=1, ncol=2), \"f\"))\n  #\n  #if (norm(matrix(s, nrow=1, ncol=2), \"f\") < epsilon_for_finish_criteria) break\n  \n  \n  if (norm(s) == 0) {\n    A_prev = A0\n    restarts[[length(restarts)+1]] = c(\"norm_s\", iteration_number)\n    adjacent_restarts_number = adjacent_restarts_number + 1\n    \n    cat(\"RESTART!\\n\\n\")\n    next\n  }\n  \n  s = s / norm(s, \"f\") \n  \n  cat(\"Direction:        \\n\")\n  print(s)\n  cat(\"\\n\")\n  \n  #lambda=0.001\n  \n  #lambda = method_dsk(f_by_direction(f, x_prev, s), 0, get_svenn_accuracy(iteration_number), get_1d_accuracy(iteration_number))[1];\n\n  #svenn_step =  min(0.0001, 0.1 * norm(matrix(x_prev, nrow=1, ncol=2), \"f\"))\n  svenn_step =  min(get_svenn_accuracy(i), 0.1 * norm(matrix(x_prev, nrow=1, ncol=2), \"f\"))\n  #svenn_step = get_svenn_accuracy(i)\n  \n  #svenn_bounds = svenn_algorithm(f_by_direction(f, x_prev, s), 0, svenn_step)\n  #lambda = method_golden_ratio(f_by_direction(f, x_prev, s), svenn_bounds[[1]], svenn_bounds[[2]], get_1d_accuracy(i))\n  #lambda = lambda[[1]][1]\n  \n  #svenn_bounds = svenn_algorithm(f_by_direction(f, x_prev, s), 0, svenn_step)\n  #lambda = method_dihotomy(f_by_direction(f, x_prev, s), svenn_bounds[[1]][1], svenn_bounds[[2]][1], get_1d_accuracy(i))\n  #lambda = lambda[1]\n  \n  lambda = method_dsk_pauell(f_by_direction(f, x_prev, s), 0, svenn_step, get_1d_accuracy(iteration_number))[1]\n  \n  cat(\"Lamda:            \", lambda, \"\\n\")\n  \n  if (lambda <= 0) {\n    A_prev = A0\n    restarts[[length(restarts)+1]] = c(lambda[1], iteration_number)\n    adjacent_restarts_number = adjacent_restarts_number + 1\n    \n    cat(\"RESTART!\\n\\n\")\n    next\n  }\n  \n  adjacent_restarts_number = 0\n  \n  x_cur = x_prev + lambda * s\n  x_cur = c(x_cur[1,1], x_cur[2,1])\n  \n  cat(\"\\nx[\", i,\"]: \")\n  print(x_cur)\n  cat(\"\\n\")\n  \n  points[[length(points)+1]] = c(x_cur, f(x_cur))\n  x_points = c(x_points, x_cur[1])\n  y_points = c(y_points, x_cur[2])\n  z_points = c(z_points, f(x_cur))\n\n  #norm_of_deltax = norm(matrix(x_prev - x_cur, nrow=1, ncol=2), \"f\") / norm(matrix(x_cur, nrow=1, ncol=2), \"f\")\n  #abs_of_deltag  = abs(f(x_prev) - f(x_cur))\n  \n  #cat(\"|f(x_k+1) - f(x_k)| = \")\n  #print(abs_of_deltag)\n  #cat(\"||x_k+1 - x_k||     = \")\n  #print(norm_of_deltax)\n  \n  #if (norm_of_deltax < epsilon_for_finish_criteria &&\n  #   abs_of_deltag < epsilon_for_finish_criteria) break\n  \n  cat(\"||grad_f(x1)||     = \")\n  print(norm(matrix(grad_f(x_cur), nrow=1, ncol=2), \"f\"))\n  \n  if (norm(matrix(grad_f(x_cur), nrow=1, ncol=2), \"f\") < epsilon_for_finish_criteria) break\n  \n  A_cur = get_next_hesse_approximation(A_prev, x_cur - x_prev, grad_f(x_cur) - grad_f(x_prev))\n\n  x_prev = x_cur\n  A_prev = A_cur\n}\n\ncat(\"Number of iterations:  \", iteration_number, \"\\n\")\ncat(\"Grinshtadts recalculations:  \", grinshtadts_recalculations, \"\\n\")\ncat(\"Function calculations: \", length(unique(f_values)), \"\\n\")\ncat(\"Gradient calculations: \", length(unique(f_grad_values)), \"\\n\")\ncat(\"Last f(x): \", f(points[[length(points)]]), \"\\n\")\ncat(\"Points:\\n\")\n#print(points)\ncat(\"Restarts:\\n\")\nprint(restarts)\n#cat(\"Last A:\\n\")\n#print(A_cur)\n\nx <- seq(-1.5, 1.5, length.out = 20)  \ny <- x\n\nrotf <- Vectorize(function(x,y){f(c(x,y))})\n\nz <- outer(x,y,rotf)\ncontour(x,y,z)\npoints(x_points, y_points, \"b\")\n",
    "created" : 1370811968843.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1700092434",
    "id" : "EB46A4EE",
    "lastKnownWriteTime" : 1370818442,
    "path" : "F:/PROJECTS/Education/3_kurs/2/Методы оптимизации/курсовая/broiden_dskp.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}