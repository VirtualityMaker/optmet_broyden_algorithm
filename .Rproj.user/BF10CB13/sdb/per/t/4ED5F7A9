{
    "contents" : "svenn_algorithm <- function(func, start_point, step)\n{\n    start_point = c(start_point, func(start_point))\n  \n    cat(\"Svenn's Algorithm report:\\n\")\n    cat(\"Start point: \")\n    print(start_point)\n    cat(\"Start step: \")\n    print(step)\n    cat(\"\\n\")\n                    \n    points <- list(start_point)\n  \n    a = c(start_point[1] - step, func(start_point[1] - step))\n    b = c(start_point[1] + step, func(start_point[1] + step))\n    \n    if (a[2] >= start_point[2] && b[2] >= start_point[2]) {\n      cat(\"a: \")\n      print(a)\n      cat(\"\\n\")\n      cat(\"b: \")\n      print(b)\n      cat(\"\\n\")\n      return(list(start_point, start_point))\n    }\n    \n    step_mod = 2\n\n    #     |\n    # . | |\n    if ((a[2] <= b[2]) &&\n        (a[2] < points[[1]][2])) {\n        step_mod <- step_mod * (-step)\n        points[[length(points)+1]] = points[[length(points)]]\n        points[[length(points)-1]] <- b\n        points[[length(points)+1]] <- a\n    }\n\n    # |   \n    # | | .\n    else if ((b[2] <= a[2]) &&\n             (b[2] < points[[1]][2])) {\n        step_mod <- step_mod * step\n        points[[length(points)+1]] = points[[length(points)]]\n        points[[length(points)-1]] <- a\n        points[[length(points)+1]] <- b\n    }\n  \n    # |   |\n    # | | |\n    else if ((a[2] == b[2]) &&\n             (a[2]  > points[[1]][2])) {\n        cat(\"RESULT:\\n\\n\")\n        print(list(a, b))\n        \n        return(list(a, b))\n    }\n  \n    while (TRUE)\n    {\n        prev_point = points[[length(points)]]\n        next_point = c(prev_point[1] + step_mod, func(prev_point[1] + step_mod))\n        \n        if (next_point[2] < prev_point[2])\n        {\n            points[[length(points)+1]] <- next_point\n            step_mod <- step_mod * 2\n        }\n        else if (next_point[2] >= prev_point[2])\n        {\n            step_mod <- step_mod / 2\n            points[[length(points)+1]] <- c(next_point[1] - step_mod, func(next_point[1] - step_mod))\n           \n            print(points)\n            cat(\"RESULT:\\n\\n\")\n            \n            result = list()\n            i = length(points)\n            if (i == 2) {\n                result = points\n            } else {\n                if (step_mod > 0) {\n                    result = list(points[[i - 2]], points[[i]])\n                } else {\n                    result = list(points[[i]], points[[i - 2]])\n                }\n            }\n            \n            print(result)\n            \n            return(result)\n        }\n    }\n}\n\nmethod_golden_ratio <- function(func, a, b, accuracy) {\n    L  = b[1] - a[1]\n    \n    x1 = c(a[1] + 0.382 * L, func(a[1] + 0.382 * L))\n    x2 = c(a[1] + 0.618 * L, func(a[1] + 0.618 * L))\n    \n    #cat(\"Golden Ratio Method report:\\n\\n\")\n    #cat('a:  ')\n    #print(a)\n    #cat('x1: ')\n    #print(x1)\n    #cat('x2: ')\n    #print(x2)\n    #cat('b:  ')\n    #print(b)\n\n    while (L > accuracy) {\n        if (x1[2] >= x2[2]) {\n            a  = x1\n            L  = b[1] - a[1]\n            \n            x1 = x2\n            x2 = c(a[1] + 0.618 * L, func(a[1] + 0.618 * L))\n        }\n        else if (x1[2] <= x2[2]) {\n            b  = x2\n            L  = b[1] - a[1]\n            \n            x2 = x1\n            x1 = c(a[1] + 0.382 * L, func(a[1] + 0.382 * L))\n        }\n        \n        #cat('\\n')\n        #cat('a:  ')\n        #print(a)\n        #cat('x1: ')\n        #print(x1)\n        #cat('x2: ')\n        #print(x2)\n        #cat('b:  ')\n        #print(b)\n    }\n    \n    #cat(\"------// END OF REPORT //------\\n\")\n    \n    return(list(a,b))\n}\n\nmethod_dihotomy <- function(func, a, b, accuracy)\n{\n    cat(\"Method dihotomy\\n\")\n    cat(\"--------------------------------\\n\")\n\n    L = b - a\n    \n    xmiddle  = (a + b) / 2\n    fxmiddle = func(xmiddle)\n    \n    while (L > accuracy) {\n        x1 = a + L/4\n        x2 = b - L/4\n        \n        fx1 = func(x1)\n        fx2 = func(x2)\n        \n        cat(\"a          = \", a, \"\\n\")\n        cat(\"b          = \", b, \"\\n\")\n        cat(\"L          = \", L, \"\\n\")\n        cat(\"x1         = \", x1, \"\\n\")\n        cat(\"f(x1)      = \", fx1, \"\\n\")\n        cat(\"x2         = \", x2, \"\\n\")\n        cat(\"f(x2)      = \", fx2, \"\\n\")\n        cat(\"xmiddle    = \", xmiddle, \"\\n\")\n        cat(\"f(xmiddle) = \", fxmiddle, \"\\n\\n\")\n        \n        if (fx1 <= fxmiddle) {\n            b        = xmiddle\n            xmiddle  = x1\n            fxmiddle = fx1\n        } else {\n            if (fx2 < fxmiddle) {\n                a        = xmiddle\n                xmiddle  = x2\n                fxmiddle = fx2\n            } else if (fx1 > fxmiddle) {\n                a = x1\n                b = x2\n            }\n        }\n\n        L = L / 2\n    }\n    \n    return(c(xmiddle, fxmiddle))\n}\n\nmethod_dsk <- function(func, start_point, svenn_step = 0.1, accuracy_var = 0.1, accuracy_func = accuracy_var)\n{\n    start_point = c(start_point, func(start_point))\n\n    while (TRUE) {\n        lst_bounds = svenn_algorithm(func, start_point[1], svenn_step)\n        a = lst_bounds[[1]]\n        b = lst_bounds[[2]]\n        \n        svenn_step = svenn_step/10\n    \n        central = c((a[1] + b[1]) / 2, func((a[1] + b[1]) / 2))\n        deltax  = abs(b[1] - central[1])\n        \n        if (a[2] - 2*central[2] + b[2] == 0) return(a)\n        \n        xpoint = central[1] + deltax * (a[2] - b[2]) / (2 * (a[2] - 2*central[2] + b[2]))\n        x = c(xpoint, func(xpoint))\n        \n        # find minimal point\n        xmin = a\n        for (itm in list(b, central)) {\n          if (xmin[2] > itm[2]) {\n            xmin = itm\n          }\n        } \n\n        cat(\"A:                      \")\n        print(a)\n        cat(\"Central point:          \")\n        print(central)\n        cat(\"B:                      \")\n        print(b)\n        cat(\"Point of minimum:       \")\n        print(xmin)\n        cat(\"\\nResult point:           \")\n        print(x)\n        cat(\"Variables check error:  \")\n        print(abs(xmin[1] - x[1]))\n        cat(\"Functions check error:  \")\n        print(abs(xmin[2] - x[2]))\n        cat('\\n')\n        \n        if ((abs(xmin[1] - x[1]) <= accuracy_var) &&\n            (abs(xmin[2] - x[2]) <= accuracy_func)) {\n            return(x)\n        } else {\n            if (xmin[2] < x[2]) {\n              start_point = xmin  \n            } else {\n              start_point = x\n            }            \n        }\n    }\n}\n\nmethod_dsk_pauell <- function(func, start_point, svenn_step = 0.1, accuracy_var = 0.1, accuracy_func = accuracy_var)\n{\n  start_point = c(start_point, func(start_point))\n  \n  lst_bounds = svenn_algorithm(func, start_point[1], svenn_step)\n  a = lst_bounds[[1]]\n  b = lst_bounds[[2]]\n  \n  central = c((a[1] + b[1]) / 2, func((a[1] + b[1]) / 2))\n  deltax  = abs(b[1] - central[1])\n  \n  if (a[2] - 2*central[2] + b[2] == 0) return(a)\n  \n  xpoint = central[1] + deltax * (a[2] - b[2]) / (2 * (a[2] - 2*central[2] + b[2]))\n  x = c(xpoint, func(xpoint))\n  \n  # find minimal point\n  xmin = a\n  for (itm in list(b, central)) {\n    if (xmin[2] > itm[2]) {\n      xmin = itm\n    }\n  } \n  \n  cat(\"A:                      \")\n  print(a)\n  cat(\"Central point:          \")\n  print(central)\n  cat(\"B:                      \")\n  print(b)\n  cat(\"Point of minimum:       \")\n  print(xmin)\n  cat(\"\\nResult point:           \")\n  print(x)\n  cat(\"Variables check error:  \")\n  print(abs(xmin[1] - x[1]))\n  cat(\"Functions check error:  \")\n  print(abs(xmin[2] - x[2]))\n  cat('\\n')\n  \n  if ((abs(xmin[1] - x[1]) <= accuracy_var) &&\n        (abs(xmin[2] - x[2]) <= accuracy_func)) {\n    return(x)\n  } else {\n    if (xmin[2] < x[2]) {\n      return(xmin)\n    }    \n  }\n  \n  x_prev = x\n  \n  cat(\"\\nStart of Pauell's algorithm\\n\\n\")\n  while (TRUE) { \n    if (x[1] < a[1]) {\n      b = central\n      central = a\n      a = x\n    } else if (x[1] < central[1]) {\n      b = central\n      central = x\n    } else if (x[1] < b[1]) {\n      a = central\n      central = x\n    } else if (x[1] > b[1]) {\n      a = central\n      central = b\n      b = x\n    }\n    \n    if (central[1] - a[1] == 0) return(a)\n    if (b[1] - central[1] == 0) return(b)\n    if (b[1] - a[1] == 0) return(b)\n    \n    a1 = (central[2] - a[2])/(central[1] - a[1])\n    a2 = ((b[2] - a[2]) / (b[1] - a[1]) - a1) / (b[1] - central[1])\n    \n    if (a2 == 0) return(b)\n    \n    x  = ((a[1] + central[1]) / 2) - (a1 / (2*a2))\n    \n    x  = c(x, func(x))\n    \n    if (x[2] == x_prev[2] && x[1] == x_prev[1]) return(x)\n    x_prev = x\n    \n    xmin = a\n    for (itm in list(b, central)) {\n      if (xmin[2] > itm[2]) {\n        xmin = itm\n      }\n    }\n    \n    cat(\"A:                      \")\n    print(a)\n    cat(\"Central point:          \")\n    print(central)\n    cat(\"B:                      \")\n    print(b)\n    cat(\"Point of minimum:       \")\n    print(xmin)\n    cat(\"\\nResult point:           \")\n    print(x)\n    cat(\"Variables check error:  \")\n    print(abs(xmin[1] - x[1]))\n    cat(\"Functions check error:  \")\n    print(abs(xmin[2] - x[2]))\n    cat('\\n')\n    \n    if ((abs(xmin[1] - x[1]) <= accuracy_var) &&\n          (abs(xmin[2] - x[2]) <= accuracy_func)) {\n      return(x)\n    } else {\n      if (x[2] > xmin[2]) {\n        t = x\n        x = xmin\n        xmin = x\n        \n        if (xmin[1] < a[1]) {\n          b = central\n          central = a\n          a = xmin\n        } else if (xmin[1] < central[1]) {\n          b = central\n          central = xmin\n        } else if (xmin[1] < b[1]) {\n          a = central\n          central = xmin\n        } else if (xmin[1] > b[1]) {\n          a = central\n          central = b\n          b = xmin\n        }\n      }    \n    }\n  }\n}",
    "created" : 1370692267609.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1638376243",
    "id" : "4ED5F7A9",
    "lastKnownWriteTime" : 1370801867,
    "path" : "F:/PROJECTS/Education/3_kurs/2/Методы оптимизации/курсовая/1d_search.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}